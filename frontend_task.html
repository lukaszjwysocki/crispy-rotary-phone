<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Users Posts</title>
	<style>
		/* I'd normally use a framework like bootstrap or tailwind, didn't want to use external libraries for this though */
		body {
			margin: 20px;
		}
		.search {
			margin-bottom: 20px;
		}
		th, td {
			padding: 15px;
			border: 1px solid #ccc;
			text-align: left;
		}
		th {
			background-color: #00a68f; /* Bonus points if anyone guesses where this colour comes from */
		}
		#spinner {
			display: none;
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}
		.spinner {
			border: 16px solid #f3f3f3;
			border-radius: 50%;
			border-top: 16px solid #3498db;
			width: 120px;
			height: 120px;
			animation: spin 2s linear infinite;
		}
		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}
		#error {
			color: #da3831;
			display: none;
		}
	</style>
</head>
<body>
<h1>Users and Their Latest Posts</h1>
<input type="text" id="search" class="search" placeholder="Search..." oninput="filterUsers()" />

<div id="spinner">
	<div class="spinner"></div>
</div>

<table id="user-table">
	<thead id="table-headers">
		<!-- Making a function generate these instead of just showing them makes the spinner/error message look nicer -->
		<!-- Headers -->
	</thead>
	<tbody id="user-list">
		<!-- Rows -->
	</tbody>
</table>

<div id="error">Unable to load data. Please try again later.</div>

<script>
	document.addEventListener('DOMContentLoaded', initPage);
	
	function initPage() {
		// This does produce the issue where if you spam refresh the spinner appears for a split second, would fix
		// if had more time (check if data is loaded by the time the page is loaded or some other solution)
		showSpinner();
		loadData();
	}

	async function loadData() {
		try {
			const [users, posts] = await Promise.all([fetchUsers(), fetchPosts()]);
			if (!users || !posts) return displayError();
			const userLatestPosts = mapUsersToPosts(users, posts);
			if (Object.keys(userLatestPosts).length === 0) return displayError();
			renderTable(users, userLatestPosts);
		} catch (error) {
			console.error('Error fetching data:', error);
			displayError();
		} finally {
			hideSpinner();
		}
	}

	async function fetchUsers() {
		try {
			// In the real world I'd use a framework (I'm partial to HTMX myself) and have the server return the data
			// rather than directly fetching it here, but this fits the requirements
			const response = await fetch('https://jsonplaceholder.typicode.com/users');
			if (!response.ok) throw new Error('Failed to fetch users');
			return await response.json();
		} catch (error) {
			console.error('Error fetching users:', error);
			return null;
		}
	}

	async function fetchPosts() {
		try {
			// Same as above
			const response = await fetch('https://jsonplaceholder.typicode.com/posts');
			if (!response.ok) throw new Error('Failed to fetch posts');
			return await response.json();
		} catch (error) {
			console.error('Error fetching posts:', error);
			return null;
		}
	}

	function mapUsersToPosts(users, posts) {
		const userLatestPost = {};
		posts.forEach(post => {
			if (!userLatestPost[post.userId] || post.id > userLatestPost[post.userId].id) {
				userLatestPost[post.userId] = post;
			}
		});
		return userLatestPost;
	}

	function renderTable(users, userLatestPosts) {
		const tableHeaders = generateHeaders();
		const userList = generateUserRows(users, userLatestPosts);
		document.getElementById('table-headers').innerHTML = tableHeaders;
		document.getElementById('user-list').innerHTML = userList;
	}

	function generateHeaders() {
		return `
                <tr>
                    <th>Name</th>
                    <th>Title</th>
                    <th>Body</th>
                </tr>`;
	}

	function generateUserRows(users, userLatestPosts) {
		return users.map(user => {
			const post = userLatestPosts[user.id];
			return `
                    <tr>
                        <td class="user-name">${user.name}</td>
                        <td>${post.title}</td>
                        <td>${post.body}</td>
                    </tr>`;
		}).join('');
	}

	function filterUsers() {
		// Requirements say just a substring match but this makes it a bit nicer
		const searchTerm = document.getElementById('search').value.toLowerCase();
		const rows = document.querySelectorAll('#user-list tr');
		rows.forEach(row => {
			const userName = row.querySelector('.user-name').textContent.toLowerCase();
			row.style.display = userName.includes(searchTerm) ? '' : 'none';
		});
	}

	function showSpinner() {
		document.getElementById('spinner').style.display = 'block';
	}

	function hideSpinner() {
		document.getElementById('spinner').style.display = 'none';
	}

	function displayError() {
		hideSpinner();
		document.getElementById('error').style.display = 'block';
	}

</script>
</body>
</html>